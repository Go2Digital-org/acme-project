name: Deploy to Server

on:
  push:
    branches:
      - main  # Production deployment
      - dev   # Staging deployment
  
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - production
          - staging
        default: staging

      action:
        description: 'Deployment action'
        required: true
        type: choice
        options:
          - deploy
          - rollback
          - reload
          - status
          - renew-ssl
        default: deploy

      run_migrations:
        description: 'Run database migrations'
        required: false
        type: boolean
        default: false

      clear_cache:
        description: 'Clear application cache'
        required: false
        type: boolean
        default: true

      runner_type:
        description: 'Runner type'
        required: false
        default: 'self-hosted'
        type: choice
        options:
          - github-hosted
          - self-hosted

env:
  PHP_VERSION: '8.4'
  NODE_VERSION: '20'

jobs:
  # ================================================================
  # SETUP JOB - Determine environment and action
  # ================================================================
  setup:
    name: Setup Deployment
    runs-on: ${{ (github.event.inputs.runner_type || 'self-hosted') == 'github-hosted' && 'ubuntu-latest' || fromJSON('["self-hosted", "linux"]') }}
    outputs:
      environment: ${{ steps.config.outputs.environment }}
      action: ${{ steps.config.outputs.action }}
      deploy_path: ${{ steps.config.outputs.deploy_path }}
      domain: ${{ steps.config.outputs.domain }}
      frankenphp_port: ${{ steps.config.outputs.frankenphp_port }}
    
    steps:
      - name: Configure deployment
        id: config
        run: |
          # Determine environment from trigger
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            ACTION="${{ github.event.inputs.action }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENVIRONMENT="production"
            ACTION="deploy"
          elif [ "${{ github.ref }}" == "refs/heads/dev" ]; then
            ENVIRONMENT="staging"
            ACTION="deploy"
          else
            echo "No deployment needed for this branch"
            exit 0
          fi
          
          # Set environment-specific variables
          if [ "$ENVIRONMENT" == "production" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "deploy_path=/var/www/acme-corp" >> $GITHUB_OUTPUT
            echo "domain=acme-corp.go2digit.al" >> $GITHUB_OUTPUT
            echo "frankenphp_port=8080" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "deploy_path=/var/www/acme-staging" >> $GITHUB_OUTPUT
            echo "domain=staging.acme-corp.go2digit.al" >> $GITHUB_OUTPUT
            echo "frankenphp_port=8081" >> $GITHUB_OUTPUT
          fi
          
          echo "action=$ACTION" >> $GITHUB_OUTPUT

  # ================================================================
  # BUILD JOB - Build application artifacts
  # ================================================================
  build:
    name: Build Application
    runs-on: ${{ (github.event.inputs.runner_type || 'self-hosted') == 'github-hosted' && 'ubuntu-latest' || fromJSON('["self-hosted", "linux"]') }}
    needs: setup
    if: needs.setup.outputs.action == 'deploy'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup PHP ${{ env.PHP_VERSION }}
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ env.PHP_VERSION }}
          extensions: mbstring, mysql, redis, opcache, zip, gd, curl, bcmath, intl
          tools: composer:v2
          coverage: none
      
      - name: Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install Composer dependencies
        run: |
          composer install \
            --no-dev \
            --no-interaction \
            --prefer-dist \
            --optimize-autoloader \
            --no-progress
      
      - name: Install NPM dependencies
        run: npm ci --no-audit
      
      - name: Build production assets
        run: npm run build
      
      - name: Create deployment artifact
        run: |
          # Create FrankenPHP specific files
          mkdir -p frankenphp
          
          # Create worker.php
          cat > frankenphp/worker.php << 'EOF'
          <?php
          
          // FrankenPHP Worker Script
          require __DIR__ . '/../vendor/autoload.php';
          
          // Bootstrap Laravel
          $app = require_once __DIR__ . '/../bootstrap/app.php';
          
          // Handle requests in worker loop
          while ($request = frankenphp_handle_request()) {
              // Clone the application for this request
              $kernel = $app->make(Illuminate\Contracts\Http\Kernel::class);
              
              // Handle the request
              $response = $kernel->handle(
                  $request = Illuminate\Http\Request::capture()
              );
              
              // Send the response
              $response->send();
              
              // Terminate the kernel
              $kernel->terminate($request, $response);
              
              // Clean up for next request
              unset($kernel, $response, $request);
          }
          EOF
          
          # Create preload.php
          cat > frankenphp/preload.php << 'EOF'
          <?php
          
          // Preload Laravel framework files for better performance
          require __DIR__ . '/../vendor/autoload.php';
          
          // Preload framework files
          $frameworkFiles = [
              __DIR__ . '/../vendor/laravel/framework/src/Illuminate/Foundation/Application.php',
              __DIR__ . '/../vendor/laravel/framework/src/Illuminate/Http/Request.php',
              __DIR__ . '/../vendor/laravel/framework/src/Illuminate/Http/Response.php',
              __DIR__ . '/../vendor/laravel/framework/src/Illuminate/Routing/Router.php',
          ];
          
          foreach ($frameworkFiles as $file) {
              if (file_exists($file)) {
                  opcache_compile_file($file);
              }
          }
          
          // Preload application files
          $appFiles = glob(__DIR__ . '/../app/**/*.php');
          foreach ($appFiles as $file) {
              opcache_compile_file($file);
          }
          EOF
          
          # Copy appropriate Caddyfile based on environment
          if [ "${{ matrix.environment }}" = "production" ]; then
              cp .github/frankenphp/Caddyfile.production Caddyfile
          else
              cp .github/frankenphp/Caddyfile.staging Caddyfile
          fi
          
          # Create deployment tarball
          mkdir -p artifacts
          tar -czf artifacts/app.tar.gz \
            --exclude='artifacts' \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='tests' \
            --exclude='.env' \
            --exclude='storage/logs' \
            --exclude='storage/debugbar' \
            .
      
      - name: Upload deployment artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-${{ needs.setup.outputs.environment }}
          path: artifacts/app.tar.gz
          retention-days: 1

  # ================================================================
  # DEPLOY JOB - Deploy to Hetzner server
  # ================================================================
  deploy:
    name: Deploy to ${{ needs.setup.outputs.environment }}
    runs-on: ${{ (github.event.inputs.runner_type || 'self-hosted') == 'github-hosted' && 'ubuntu-latest' || fromJSON('["self-hosted", "linux"]') }}
    needs: [setup, build]
    if: needs.setup.outputs.action == 'deploy'
    environment:
      name: ${{ needs.setup.outputs.environment }}
      url: https://${{ needs.setup.outputs.domain }}
    
    steps:
      - name: Download deployment artifact
        uses: actions/download-artifact@v4
        with:
          name: deployment-${{ needs.setup.outputs.environment }}
          path: ./
      
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -p ${{ secrets.HETZNER_PORT || 22 }} ${{ secrets.HETZNER_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to Hetzner server
        run: |
          ssh -i ~/.ssh/deploy_key -p ${{ secrets.HETZNER_PORT || 22 }} ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            set -e
            
            # Configuration
            ENVIRONMENT="${{ needs.setup.outputs.environment }}"
            DEPLOY_PATH="${{ needs.setup.outputs.deploy_path }}"
            FRANKENPHP_PORT="${{ needs.setup.outputs.frankenphp_port }}"
            DOMAIN="${{ needs.setup.outputs.domain }}"
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            RELEASE_PATH="$DEPLOY_PATH/releases/$TIMESTAMP"
            
            echo "üöÄ Starting deployment to $ENVIRONMENT environment..."
            
            # Create deployment directories
            mkdir -p "$DEPLOY_PATH/releases"
            mkdir -p "$DEPLOY_PATH/storage/app/public"
            mkdir -p "$DEPLOY_PATH/storage/framework/cache"
            mkdir -p "$DEPLOY_PATH/storage/framework/sessions"
            mkdir -p "$DEPLOY_PATH/storage/framework/views"
            mkdir -p "$DEPLOY_PATH/storage/logs"

            # Create new release directory
            mkdir -p "$RELEASE_PATH"
            
            echo "üì¶ Deployment directories prepared"
          EOF

      - name: Upload and extract artifact
        run: |
          # First, upload the artifact to a temporary location
          echo "üì§ Uploading artifact to server..."
          scp -i ~/.ssh/deploy_key -P ${{ secrets.HETZNER_PORT || 22 }} app.tar.gz ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }}:/tmp/app-deploy-${{ github.run_id }}.tar.gz

          # Then move it to the correct release directory and extract
          ssh -i ~/.ssh/deploy_key -p ${{ secrets.HETZNER_PORT || 22 }} ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'DEPLOY_EOF'
            set -e
            DEPLOY_PATH="${{ needs.setup.outputs.deploy_path }}"

            # Get the latest release directory
            LATEST_RELEASE=$(ls -t "$DEPLOY_PATH/releases/" | head -1)
            RELEASE_PATH="$DEPLOY_PATH/releases/$LATEST_RELEASE"

            echo "üì¶ Extracting to release: $LATEST_RELEASE"

            # Move and extract the artifact
            mv /tmp/app-deploy-${{ github.run_id }}.tar.gz "$RELEASE_PATH/app.tar.gz"
            cd "$RELEASE_PATH"
            tar -xzf app.tar.gz
            rm app.tar.gz

            echo "‚úÖ Artifact extracted successfully"
          DEPLOY_EOF
      
      - name: Configure and start application
        run: |
          ssh -i ~/.ssh/deploy_key -p ${{ secrets.HETZNER_PORT || 22 }} ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            set -e
            
            # Configuration
            ENVIRONMENT="${{ needs.setup.outputs.environment }}"
            DEPLOY_PATH="${{ needs.setup.outputs.deploy_path }}"
            FRANKENPHP_PORT="${{ needs.setup.outputs.frankenphp_port }}"
            DOMAIN="${{ needs.setup.outputs.domain }}"
            TIMESTAMP=$(ls -t "$DEPLOY_PATH/releases" | head -1)
            RELEASE_PATH="$DEPLOY_PATH/releases/$TIMESTAMP"

            echo "üì¶ Configuring release: $TIMESTAMP"
            cd "$RELEASE_PATH"

            # Configure Caddyfile
            sed -i "s/FRANKENPHP_PORT/$FRANKENPHP_PORT/g" Caddyfile
            sed -i "s|DEPLOY_PATH|${DEPLOY_PATH##*/}|g" Caddyfile
            sed -i "s/ENVIRONMENT/$ENVIRONMENT/g" Caddyfile
            
            # Link shared directories and files
            ln -nfs "$DEPLOY_PATH/storage" "$RELEASE_PATH/storage"
            ln -nfs "$DEPLOY_PATH/.env" "$RELEASE_PATH/.env"
            
            # Set permissions
            chown -R www-data:www-data "$RELEASE_PATH"
            chmod -R 755 "$RELEASE_PATH"
            chmod -R 775 "$DEPLOY_PATH/storage"
            
            # Run Laravel deployment tasks
            cd "$RELEASE_PATH"
            
            # Generate application key if needed
            if ! grep -q "APP_KEY=" "$DEPLOY_PATH/.env"; then
              php artisan key:generate --force
            fi
            
            # Create storage link
            echo "üîó Creating storage link..."
            php artisan storage:link --force

            # Publish vendor assets
            echo "üì¶ Publishing Livewire assets..."
            php artisan vendor:publish --tag=livewire:assets --force

            echo "üé® Publishing Filament assets..."
            php artisan filament:assets
            php artisan filament:cache-components

            # Fix permissions for published assets
            chown -R www-data:www-data "$RELEASE_PATH/public/vendor"

            # Run migrations if explicitly requested (default: skip for automated deployments)
            RUN_MIGRATIONS="${{ github.event.inputs.run_migrations }}"
            # For push events, default to false unless explicitly set
            if [ "${{ github.event_name }}" = "push" ]; then
              RUN_MIGRATIONS="false"
            fi

            if [ "$RUN_MIGRATIONS" = "true" ]; then
              echo "üóÑÔ∏è Running database migrations..."
              php artisan migrate --force
            else
              echo "‚è≠Ô∏è Skipping database migrations (run manually if needed)"
            fi
            
            # Clear and optimize caches
            if [ "${{ github.event.inputs.clear_cache }}" != "false" ]; then
              echo "üßπ Clearing caches..."
              php artisan config:clear
              php artisan cache:clear
              php artisan view:clear
              php artisan route:clear
              
              echo "‚ö° Optimizing application..."
              php artisan config:cache
              php artisan route:cache
              php artisan view:cache
            fi
            
            # Update symlink for zero-downtime deployment
            echo "üîÑ Switching to new release..."
            ln -nfs "$RELEASE_PATH" "$DEPLOY_PATH/current"
            
            # Clear all optimizations to ensure fresh state
            echo "üßπ Running optimize:clear for fresh state..."
            cd "$DEPLOY_PATH/current"
            php artisan optimize:clear
            
            # Restart FrankenPHP service (full restart to clear cache)
            echo "üîÑ Restarting FrankenPHP (full restart to clear cache)..."
            systemctl restart frankenphp-$ENVIRONMENT
            
            # Deploy environment-specific configurations
            echo "‚öôÔ∏è Deploying $ENVIRONMENT configurations..."
            if [ "$ENVIRONMENT" = "staging" ]; then
              # Deploy staging supervisor configuration
              if [ -f "$RELEASE_PATH/.github/deployment/staging/supervisor-workers.conf" ]; then
                echo "üìã Installing staging supervisor configuration..."
                cp "$RELEASE_PATH/.github/deployment/staging/supervisor-workers.conf" /etc/supervisor/conf.d/acme-staging-workers.conf
                supervisorctl reread
                supervisorctl update
              fi
              
              # Deploy staging crontab
              if [ -f "$RELEASE_PATH/.github/deployment/staging/crontab" ]; then
                echo "‚è∞ Installing staging crontab..."
                crontab -u www-data "$RELEASE_PATH/.github/deployment/staging/crontab"
              fi
            else
              # Deploy production supervisor configuration
              if [ -f "$RELEASE_PATH/.github/deployment/production/supervisor-workers.conf" ]; then
                echo "üìã Installing production supervisor configuration..."
                cp "$RELEASE_PATH/.github/deployment/production/supervisor-workers.conf" /etc/supervisor/conf.d/acme-corp-workers.conf
                supervisorctl reread
                supervisorctl update
              fi
              
              # Deploy production crontab
              if [ -f "$RELEASE_PATH/.github/deployment/production/crontab" ]; then
                echo "‚è∞ Installing production crontab..."
                crontab -u www-data "$RELEASE_PATH/.github/deployment/production/crontab"
              fi
            fi
            
            # Restart queue workers (environment-specific)
            echo "üîÑ Restarting queue workers..."
            if [ "$ENVIRONMENT" = "staging" ]; then
              timeout 10 supervisorctl restart acme-staging-workers:* || {
                echo "‚ö†Ô∏è Worker restart timed out, using stop/start instead..."
                supervisorctl stop acme-staging-workers:* || true
                sleep 2
                supervisorctl start acme-staging-workers:* || true
              }
            else
              timeout 10 supervisorctl restart acme-workers:* || {
                echo "‚ö†Ô∏è Worker restart timed out, using stop/start instead..."
                supervisorctl stop acme-workers:* || true
                sleep 2
                supervisorctl start acme-workers:* || true
              }
            fi
            
            # Verify Meilisearch health
            echo "üîç Verifying Meilisearch health..."
            cd "$DEPLOY_PATH/current"
            if [ -f "scripts/meilisearch-monitor.sh" ]; then
              chmod +x scripts/meilisearch-monitor.sh
              ./scripts/meilisearch-monitor.sh --check=health --quiet || echo "Meilisearch health check failed, but continuing..."
            fi
            
            # Clean up old releases (keep last 5)
            cd "$DEPLOY_PATH/releases"
            ls -t | tail -n +6 | xargs -r rm -rf
            
            echo "‚úÖ Deployment completed successfully!"
          EOF

      - name: Deployment summary
        run: |
          # Determine protocol based on environment
          if [ "${{ needs.setup.outputs.environment }}" = "production" ]; then
            PROTOCOL="https"
          else
            PROTOCOL="http"
          fi
          
          echo "üéâ Deployment to ${{ needs.setup.outputs.environment }} completed successfully!"
          echo "üåê URL: ${PROTOCOL}://${{ needs.setup.outputs.domain }}"
          echo "üîç Meilisearch integration: Configured and verified"

  # ================================================================
  # ROLLBACK JOB - Rollback to previous release
  # ================================================================
  rollback:
    name: Rollback ${{ needs.setup.outputs.environment }}
    runs-on: ${{ (github.event.inputs.runner_type || 'self-hosted') == 'github-hosted' && 'ubuntu-latest' || fromJSON('["self-hosted", "linux"]') }}
    needs: setup
    if: needs.setup.outputs.action == 'rollback'
    environment:
      name: ${{ needs.setup.outputs.environment }}
    
    steps:
      - name: Rollback deployment
        run: |
          ssh -i ~/.ssh/deploy_key -p ${{ secrets.HETZNER_PORT || 22 }} ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            set -e
            
            DEPLOY_PATH="${{ needs.setup.outputs.deploy_path }}"
            ENVIRONMENT="${{ needs.setup.outputs.environment }}"
            
            echo "‚è™ Starting rollback for $ENVIRONMENT..."
            
            # Get current and previous release
            CURRENT=$(readlink "$DEPLOY_PATH/current" | xargs basename)
            PREVIOUS=$(ls -t "$DEPLOY_PATH/releases" | grep -v "$CURRENT" | head -1)
            
            if [ -z "$PREVIOUS" ]; then
              echo "‚ùå No previous release found to rollback to!"
              exit 1
            fi
            
            echo "Rolling back from $CURRENT to $PREVIOUS..."
            
            # Switch symlink to previous release
            ln -nfs "$DEPLOY_PATH/releases/$PREVIOUS" "$DEPLOY_PATH/current"
            
            # Clear caches and restart FrankenPHP
            cd "$DEPLOY_PATH/current"
            php artisan optimize:clear
            systemctl restart frankenphp-$ENVIRONMENT
            
            echo "‚úÖ Rollback completed successfully!"
          EOF

  # ================================================================
  # RELOAD JOB - Graceful reload of FrankenPHP
  # ================================================================
  reload:
    name: Reload FrankenPHP
    runs-on: ${{ (github.event.inputs.runner_type || 'self-hosted') == 'github-hosted' && 'ubuntu-latest' || fromJSON('["self-hosted", "linux"]') }}
    needs: setup
    if: needs.setup.outputs.action == 'reload'
    
    steps:
      - name: Reload FrankenPHP service
        run: |
          ssh -i ~/.ssh/deploy_key -p ${{ secrets.HETZNER_PORT || 22 }} ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            ENVIRONMENT="${{ needs.setup.outputs.environment }}"
            DEPLOY_PATH="${{ needs.setup.outputs.deploy_path }}"
            
            echo "üßπ Clearing caches..."
            cd "$DEPLOY_PATH/current"
            php artisan optimize:clear
            
            echo "üîÑ Restarting FrankenPHP for $ENVIRONMENT..."
            systemctl restart frankenphp-$ENVIRONMENT
            
            # Verify service is running
            sleep 2
            if systemctl is-active --quiet frankenphp-$ENVIRONMENT; then
              echo "‚úÖ FrankenPHP restarted successfully!"
            else
              echo "‚ùå FrankenPHP restart failed!"
              exit 1
            fi
          EOF

  # ================================================================
  # STATUS JOB - Check deployment status
  # ================================================================
  status:
    name: Check Status
    runs-on: ${{ (github.event.inputs.runner_type || 'self-hosted') == 'github-hosted' && 'ubuntu-latest' || fromJSON('["self-hosted", "linux"]') }}
    needs: setup
    if: needs.setup.outputs.action == 'status'
    
    steps:
      - name: Check deployment status
        run: |
          ssh -i ~/.ssh/deploy_key -p ${{ secrets.HETZNER_PORT || 22 }} ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            DEPLOY_PATH="${{ needs.setup.outputs.deploy_path }}"
            ENVIRONMENT="${{ needs.setup.outputs.environment }}"
            DOMAIN="${{ needs.setup.outputs.domain }}"
            
            echo "üìä Deployment Status for $ENVIRONMENT"
            echo "================================="
            
            # Current release
            if [ -L "$DEPLOY_PATH/current" ]; then
              CURRENT=$(readlink "$DEPLOY_PATH/current" | xargs basename)
              echo "üìÅ Current release: $CURRENT"
            else
              echo "‚ùå No current release found!"
            fi
            
            # Available releases
            echo -e "\nüì¶ Available releases:"
            ls -lt "$DEPLOY_PATH/releases" | head -5
            
            # FrankenPHP status
            echo -e "\nüöÄ FrankenPHP Status:"
            systemctl status frankenphp-$ENVIRONMENT --no-pager | head -10
            
            # SSL certificate status
            echo -e "\nüîí SSL Certificate Status:"
            echo | openssl s_client -servername $DOMAIN -connect $DOMAIN:443 2>/dev/null | openssl x509 -noout -dates
            
            # Health check
            echo -e "\n‚ù§Ô∏è Health Check:"
            curl -s https://$DOMAIN/health || echo "Health check failed"

  # ================================================================
  # SSL RENEWAL JOB - Renew SSL certificates
  # ================================================================
  renew-ssl:
    name: Renew SSL Certificates
    runs-on: ${{ (github.event.inputs.runner_type || 'self-hosted') == 'github-hosted' && 'ubuntu-latest' || fromJSON('["self-hosted", "linux"]') }}
    needs: setup
    if: needs.setup.outputs.action == 'renew-ssl'
    
    steps:
      - name: Renew SSL certificates
        run: |
          ssh -i ~/.ssh/deploy_key -p ${{ secrets.HETZNER_PORT || 22 }} ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} << 'EOF'
            DOMAIN="${{ needs.setup.outputs.domain }}"
            
            echo "üîí Renewing SSL certificate for $DOMAIN..."
            
            # Renew certificate
            certbot renew --cert-name $DOMAIN --quiet
            
            # Reload Nginx to use new certificate
            systemctl reload nginx
            
            # Check certificate expiry
            echo -e "\nüìÖ Certificate expiry:"
            echo | openssl s_client -servername $DOMAIN -connect $DOMAIN:443 2>/dev/null | openssl x509 -noout -dates
            
            echo "‚úÖ SSL renewal completed!"
          EOF